/*
 * Copyright (C) 2004-2009 Institute for Computational Biomedicine,
 *                         Weill Medical College of Cornell University
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package textractor.util;

import edu.mssm.crover.cli.CLI;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.util.zip.GZIPInputStream;

/**
 * Created by IntelliJ IDEA.
 * User: campagne
 * Date: Dec 5, 2003
 * Time: 12:36:26 PM
 * To change this template use Options | File Templates.
 */
public abstract class ProcessDirectory {
    private static final Log log = LogFactory.getLog(ProcessDirectory.class);
    private String fileFilterExtension1;
    private String fileFilterExtension2;
    private String input_fn;
    private final String directory;
    private final String url;
    private final String output_extension;
    private final boolean verbose;

    /**
     * Sets the extension to use for the files generated by the processing.
     * fileFilterExtensions are removed from the input file name and replaced by
     * the ouptut file extension. This occurs when a whole directory is
     * processed. Specific writer filename can still be given when a single file
     * is processed by using the -o option in the argument.
     */
    public final void setOutputFileExtension(final String outputFileExtension) {
    }

    /**
     * Sets the extension of the files that will be processed. Files in the
     * directory should match this extension (or the second extension, see
     * setFileFilterExtension2) in order to be processed.
     */
    public final void setFileFilterExtension1(final String fileFilterExtension1) {
        this.fileFilterExtension1 = fileFilterExtension1;

    }

    /**
     * Sets the value of the second filename extension. See
     * setFileFilterExtension1.
     */
    public final void setFileFilterExtension2(final String fileFilterExtension2) {
        this.fileFilterExtension2 = fileFilterExtension2;
    }

    public ProcessDirectory(final String[] args, final String filterExtension1) {
        // the HTML to convert
        input_fn = CLI.getOption(args, "-i", null); // input file name
        fileFilterExtension2 = CLI.getOption(args, "-ext", null); // extension for files to match input file in directory
        directory = CLI.getOption(args, "-d", null); // directory with html files. Files must have extension .htm or .html to be processed. Extesion .txt is assumed for writer.
        url = CLI.getOption(args, "-url", "http://icb.med.cornell.edu");
        output_extension = CLI.getOption(args, "-oe", null); // extension for writer files, if no writer filename given with -o

        verbose = CLI.isKeywordGiven(args, "-v", false);
        if (filterExtension1 != null) {
            this.setFileFilterExtension1(filterExtension1);
        }
        if (output_extension != null) {
            this.setOutputFileExtension(output_extension);
        }

    }

    public final void process() throws IOException {
        if (directory != null) {
            //System.out.println("directory = " + directory);
            final File dir = new File(directory);
            if (dir.isDirectory()) {
                processDirectory(dir, verbose);
            } else {
                log.error("-d must be followed with the name of a directory.");
            }
        } else {
            Reader in = null;
            if (input_fn != null) {
                if (input_fn.endsWith(".gz")) { // uncompress gzip files as needed.
                    final GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(input_fn));
                    in = new InputStreamReader(gzis);
                } else {
                    in = new FileReader(input_fn);
                }
            } else {
                if (url != null) {
                    final URL source = new URL(url);
                    final DataInputStream dis = new DataInputStream(source.openStream());
                    in = new InputStreamReader(dis);
                }
                input_fn = "from_an_url";
            }

            if (in == null) {
                log.error("Cannot determine source from arguments. " +
                        "Must specify either -i file or -url url. Files have priority.");
                System.exit(0);
            }
            processFile(in, input_fn, deriveOutputFilename(input_fn));
        }
    }

    public final void processDirectory(final File directory, final boolean verbose) throws IOException {
        if (verbose) {
	    System.out.println("Converting directory " + directory.getAbsolutePath());
	}
        final File[] files = directory.listFiles();
        for (int i = 0; i < files.length; ++i) {
            if (files[i].isFile()) {
                input_fn = files[i].getAbsolutePath();
                if (accept(input_fn)) {
                    if (verbose) {
			System.out.println("Converting file " + files[i].getAbsolutePath());
		    }
                    processFile(new FileReader(files[i]), files[i].getAbsolutePath(), deriveOutputFilename(input_fn));
                }
            } else if (files[i].isDirectory()) {
                processDirectory(files[i], verbose);
            }
        }
    }

    public final boolean accept(final String filename) {
        if (filename.lastIndexOf('.') == -1) {
	    return false; // no . in filename
	}
        final String extension = filename.substring(filename.lastIndexOf('.'), filename.length());
        return extension.equals(fileFilterExtension1) ||
                extension.equals(fileFilterExtension2);
    }

    public final String deriveOutputFilename(final String input_fn) {
        if (input_fn == null) {
            return null;
        }

        final StringBuffer sb;
        final int ext_index = input_fn.lastIndexOf('.');
        if (ext_index >= 0) {
            sb = new StringBuffer(input_fn.substring(0, ext_index));
        } else {
            sb = new StringBuffer(input_fn);
        }
        sb.append(output_extension);
        return sb.toString();
    }

    public abstract void processFile(Reader reader, String filename, String output_filename) throws IOException;
}
